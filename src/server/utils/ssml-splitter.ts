export const splitSsml = (ssml: string, limit: number = 4000): string[] => {
  // Extract inner content from <speak><prosody>...</prosody></speak>
  // We assume the standard structure generated by our client
  const openTagsRegex = /<speak>\s*<prosody>/;
  const closeTagsRegex = /<\/prosody>\s*<\/speak>/;

  let innerContent = ssml;
  const openMatch = ssml.match(openTagsRegex);
  const closeMatch = ssml.match(closeTagsRegex);

  if (openMatch && closeMatch) {
    innerContent = ssml.substring(
      openMatch.index! + openMatch[0].length,
      closeMatch.index!
    );
  }

  const chunks: string[] = [];
  let currentChunk = "";

  // Regex to match tags or non-tag content
  // <[^>]+> matches any tag
  // [^<]+ matches any text between tags
  const regex = /<[^>]+>|[^<]+/g;
  let match;

  while ((match = regex.exec(innerContent)) !== null) {
    const token = match[0];

    if (currentChunk.length + token.length > limit) {
      // If adding this token exceeds limit, push current chunk and start new
      if (currentChunk.length > 0) {
        chunks.push(`<speak><prosody>${currentChunk}</prosody></speak>`);
        currentChunk = "";
      }
    }
    currentChunk += token;
  }

  if (currentChunk.length > 0) {
    chunks.push(`<speak><prosody>${currentChunk}</prosody></speak>`);
  }

  return chunks;
};

